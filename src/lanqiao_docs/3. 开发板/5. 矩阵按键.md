# 矩阵按键

矩阵按键是由4x4排列的按键组成，我们来看看原理图。现在我们要检测按下**单个按键**和匹配按下的时间是长还是短。

![QQ_1759583053582](./%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE.assets/QQ_1759583053582.png)

每个按键都连接着GPIO，每个GPIO连接着4个按键。

我们来看看两侧连接的是哪8个GPIO。

![QQ_1759585140731](./%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE.assets/QQ_1759585140731.png)

我们分为x轴和y轴，

x轴的GPIO为`P30` `P31` `P32`  `P33`，

y轴的GPIO为`P44` `P42` `P35` `P34`，

让我们想想，我们如何快速的获取16个按键哪个被按下呢？

我们来看看赵老师开源的代码是如何实现的。

```c
#include "key.h"

uint8_t key_scan()
{
    static uint8_t i, state, value;
    uint8_t temp = 99, press = 0xFF;

    P3 = 0x0F;		// P30 -> 1 P31 -> 1 P32 -> 1 P33 -> 1
    			   // P34 -> 0 P35 -> 0 P42 -> 0 P44 -> 0
    P42 = 0; P44 = 0;
    P36 = P42; P36 = P44;

    press = P3 & 0x0F;	// 记录前4位的值，也就是x坐标轴的值

    switch (state)
    {
        case 0:
        {
            if (press != 0x0F)	// 如果x坐标中由引脚被拉低
            {
                state = 1;
            }
            break;
        }

        case 1:
        {
            if (press == 0x0F)
            {
                state = 0;
            }
            else
            {
                P3 = press | 0xF0;	//将y轴置位1 x轴不变
                P42 = 1; P44 = 1;
                P35 = P42; P36 = P44;

                press = P3;	// 按下的引脚会被拉低，获取按下的引脚y坐标

                state = 2;

                switch (press)
                {
                    case 0x77: {value = 4; break;}
                    case 0x7B: {value = 5; break;}
                    case 0x7D: {value = 6; break;}
                    case 0x7E: {value = 7; break;}

                    case 0xB7: {value = 8; break;}
                    case 0xBB: {value = 9; break;}
                    case 0xBD: {value = 10; break;}
                    case 0xBE: {value = 11; break;}

                    case 0xD7: {value = 12; break;}
                    case 0xDB: {value = 13; break;}
                    case 0xDD: {value = 14; break;}
                    case 0xDE: {value = 15; break;}

                    case 0xE7: {value = 16; break;}
                    case 0xEB: {value = 17; break;}
                    case 0xED: {value = 18; break;}
                    case 0xEE: {value = 19; break;}
                    default: {state = 0;}
                }
            }
        }
        break;

        case 2:
        {
            if (press == 0x0F)
            {
                i++;
                if (i >= 150)
                {
                    i = 0;
                    state = 3;
                }
            }
            else
            {
                i = 0;
                temp = value;
                value = 0;
                state = 0;
            }
        }
        break;

        case 3:
        {
            if (press == 0x0F)
            {
                temp = value + 20;
                value = 0;
                state = 0;
            }
        }
        break;
    }
    return temp;
}
```

首先将x轴的GPIO设置为高电平，y轴的GPIO为低电平。

如果按键按下后，x轴的GPIO会拉低到低电平，我们这时候记录一下此时P3寄存器的16进制值，

然后保持x的值不变，将y轴置位高电平，x轴不变，

这时被按下的按键中，y轴的GPIO会拉到低电平，

这时候再读取一次整合好的2个轴的十六进制值，

我们会发现，按下的按键把两个引脚置为低电平，而其他引脚为高电平，

我们此时进行匹配，来获取按下的结果。

> 为什么x轴引脚的电平会被拉低，而不是y轴引脚的电平拉高？
>
> 我们设置引脚为准双向口，当我们写`P42 = 1;` 时，**引脚变成输入模式**，并有上拉电阻。所以给一个0v时会被拉低。
>
> 当我们配置P42 = 0; 时，将强力输出低电平，由mos管将引脚接地。这时输出能力强，可以吸收电流。

我们来看switch将扫描分为4个部分。

第一部分，将x轴设置为高电平，y轴设置为低电平，等待按键按下。如果有按键按下进入第二部分。9

第二部分，首先消抖，如果有抖动会跳到第一部分。按键确实按下后，会保持x电平不变，y轴设置为高电平，然后获取8个GPIO的16进制值，然后进行匹配。匹配后进入第三状态。

第三部分，当按键按下时，会进入累加状态，在范围值内定义为点按键，超过范围值会跳到第四部分，定义为长按键，然后返回值。

短按键返回值为按键的位号，长按键返回值为按键的位号+20。

我们通过定时器的中断函数来10ms轮询按键是否按下，通过调用函数我们可以获取按下的是哪个键，然后来进行我们想要的操作。

> 进阶：我们可以以此实现双按键的检测和是否松手才返回值。







## 测试



P34  为高电平