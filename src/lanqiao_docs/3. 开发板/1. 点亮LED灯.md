#  点亮 LED 灯 

学习单片机最经典的第一步，就是 **点亮一颗 LED 灯**。
虽然简单，但这一步包含了 **引脚控制、电路逻辑、锁存器原理、译码器选择** 等一整套控制流程。

为了让你真正理解“为什么这样写代码就能亮灯”，我们从 **电路 → 芯片 → 时序 → 代码** 的顺序展开。

开发板上的 LED 并不是直接连在单片机的引脚上，而是经过多个逻辑芯片：

```
P0 ——> 74HC573（输出锁存） ——> LED  
P2.5~P2.7 ——> 74HC138（译码器，选择哪个 573）  
P2.x ——> LE（控制锁存时机）
```

整个流程：

> **P0 写灯光数据 → 选择 573 → LE 锁存 → LED 点亮**


---

## LED灯

开发板上的 LED 使用 **0603 封装**，非常小：

<img src="./%E7%82%B9%E4%BA%AElED%E7%81%AF2.assets/19A23F6943857869CBE27DE741B1F55B.jpg" alt="A-SP192DGHC-C01-4T实物图" style="zoom:25%;" />

LED 点亮条件：

> **正极接高电压（5V / 3.3V），负极接低电平（GND）即亮。**



## 74HC573 锁存器

在原理图中，8 个 LED 的负极全部连接在 **74HC573 的 12~19 引脚（Q0~Q7）** 上：

<img src="./%E7%82%B9%E4%BA%AElED%E7%81%AF2.assets/image-20250927133133263.png" alt="原理图" style="zoom:50%;" />

在本开发板中： **74HC573 输出端← 负极  LED 正极 ← 限流电阻 ← 5V**

> **为什么使用74HC573芯片，而不是LED灯直接接在开发板上？**
>
> 由于51单片机引脚有限，我们需要实现数码管、LED灯同时点亮。如果都直接连接的话，需要24个引脚。
>
> 通过三八译码器控制8个锁存器告诉切换，来实现引脚扩展，避免引脚不够用的情况。

> **为什么LED灯的正极不接在单片机引脚上，而是负极接在单片机引脚上？这样单片机配置高电平是灭灯，低电平时亮灯。**
>
> 这个与51单片机的引脚结构有关。
>
> 当引脚输出为低时，**它的驱动能力很强， 可吸收相当大的电流。**
>
> 当引脚输出为高时，引脚通过电阻与VCC连接，但电流特别小，为若上拉。此时也做输入引脚，允许外部将引脚拉低。

所以：

> **想让 LED 亮，只需让 74HC573 对应输出脚为低电平，即0V**

因此我们需要先了解这个芯片。

---

### 1. 芯片外观

<img src="./%E7%82%B9%E4%BA%AElED%E7%81%AF2.assets/671C96A40BA1A6914AC0E172685B2FE7.jpg" alt="芯片外观" style="zoom:33%;" />

---

### 2. 它是干什么的？

**74HC573 = 8 位数据锁存器（Octal Transparent Latch）**

作用：

* 暂存 8 bit 数据
* 控制输出是否有效
* 让 LED 电平保持稳定

---

### 3. 引脚功能

![QQ_1768920201950](./%E7%82%B9%E4%BA%AELED%E7%81%AF2.assets/QQ_1768920201950.png)

| 引脚  | 名称  |            功能            |      |
| :---: | :---: | :------------------------: | :--: |
|  2~9  | D0~D7 |       输入（接 P0）        |      |
| 19~12 | Q0~Q7 |       输出（接 LED）       |      |
|  11   |  LE   | 锁存允许（高透明、低锁存） |      |
|   1   |  #OE  |   输出使能（低电平有效）   |      |
|  20   |  VCC  |      电源引脚，最大7V      |      |
|  10   |  GND  |          接地引脚          |      |

---

### 4. 工作方式（核心）

| LE引脚 |             功能             |
| :----: | :--------------------------: |
|   1    |    输入 → 直接透传到输出     |
|   0    | 锁存上一次输入，保持输出不变 |

所以点灯流程为：

> **让 LE 高电平→锁存器为透明状态→写 P0 数据，**
>
> **再让 LE 低电平→锁存器为锁存状态 → 锁住LE为高电平时的P0数据→后续P0任何变化都不影响锁存器输出→点亮指定 LED**

---

## 74HC02 —— 信号反相（或非门）

<img src="./%E7%82%B9%E4%BA%AElED%E7%81%AF2.assets/ED07E25F32818007EFDCA1FBBB2E90A5.jpg" style="zoom:33%;" />

在原理图中，74HC02 的两个输入引脚的其中一个接地，使它变成一个 **简单反相器**。

<img src="./%E7%82%B9%E4%BA%AElED%E7%81%AF2.assets/QQ_1758952942382.png" alt="QQ\_1758952942382" style="zoom:67%;" />

逻辑如下：

| 输入Y4 | 输出Y4C |
| :----: | :-----: |
|   0    |    1    |
|   1    |    0    |

它的作用是：

> **把三八译码器的控制信号反相，得到需要的低电平信号。**



这用于某些电路控制，但在“点灯流程”中你只需要知道：
**信号经过它后电平会取反。**

---

## 74HC138 —— 选择哪个锁存器工作

<img src="./%E7%82%B9%E4%BA%AElED%E7%81%AF2.assets/79A89FC7DE84C54C326B7274BCB233BA.jpg" style="zoom:33%;" />

![芯片原理图](./%E7%82%B9%E4%BA%AELED%E7%81%AF2.assets/QQ_1762503934511-1762505864759-2.png)

开发板上有多个 74HC573。
那么单片机要如何告诉硬件：

> “我要操作第 4 号锁存器！”

*我们可以使用 **74HC138 三选八译码器**，来在多个锁存器中**选择其中一个**进行操作。*

*三八译码器可以根据输入，选择一个引脚变为低电平，其余引脚变为高电平。*

*由于锁存器的控制引脚LE**高电平为透明模式，低电平为锁存模式**，我们操作锁存器时，先让**其中一个锁存器为透明模式，其他锁存器为锁存状态**，只允许P0引脚操作一个锁存器，避免影响其他锁存器的数据，来实现引脚的拓展。*

*也就是说，需要8个锁存器的控制引脚**其中一个为高电平，其余都为低电平。**正好与38译码器控制逻辑相反。*

*所以我们需要三八译码器的**输出信号进行取反**，然后输入到锁存器控制引脚中。*

---

###  芯片作用

输入 3 位信号 A2 A1 A0 → 在 8 个输出中选择 1 个变为低电平。

对 573 来说，这个低电平就是“被选中”。

| 引脚  | 状态 |
| --- | -- |
| G2A | 0  |
| G2B | 0  |
| G1  | 1  |

因此芯片始终处于 **使能状态**。

---

### 如何选择第 4 号锁存器？

<img src="./%E7%82%B9%E4%BA%AElED%E7%81%AF2.assets/QQ_1758954577525.png" alt="QQ\_1758954577525" style="zoom: 50%;" />

查真值表可知：

> Y4 为低电平时 → 选中第 4 号锁存器
> 所需输入为 **A2 A1 A0 = 100**

在开发板中对应：

| A2   | A1   | A0   |
| ---- | ---- | ---- |
| P2.7 | P2.6 | P2.5 |

所以代码为：

```c
P2 = (P2 & 0x1F) | 0x80;
```

---

## 点亮 LED 的完整流程

现在我们把所有知识串起来：

### 硬件电路
- 51单片机引出P0引脚
![QQ_1768918910889](./%E7%82%B9%E4%BA%AELED%E7%81%AF2.assets/QQ_1768918910889.png)
- P0网络通过短接符修改为D0

![QQ_1768918978949](./%E7%82%B9%E4%BA%AELED%E7%81%AF2.assets/QQ_1768918978949.png)



- D0与锁存器芯片输入端连接，锁存器输出端与LED灯连接。锁存器的控制引脚网络名称为Y4C。

![QQ_1768919052473](./%E7%82%B9%E4%BA%AELED%E7%81%AF2.assets/QQ_1768919052473.png)



Y4C信号：

- 51单片机的P25 p26 P27引出，通过短接符修改网络名为A0,A1,A2。 

![QQ_1768919425105](./%E7%82%B9%E4%BA%AELED%E7%81%AF2.assets/QQ_1768919425105.png)

<img src="./%E7%82%B9%E4%BA%AELED%E7%81%AF2.assets/QQ_1768919524769.png" alt="QQ_1768919524769" style="zoom:80%;" />

- 51单片机的三个引脚接入`三八译码器`的三端输入引脚，输出引脚连接`与或门芯片`进行取反。

![QQ_1768919235766](./%E7%82%B9%E4%BA%AELED%E7%81%AF2.assets/QQ_1768919235766.png)

- 通过`与或门芯片`实现信号的取反，Y4为信号输入，Y4C为信号输出。Y4C为Y4电平的反转。

<img src="./%E7%82%B9%E4%BA%AELED%E7%81%AF2.assets/QQ_1768919648546.png" alt="QQ_1768919648546" style="zoom: 67%;" />

- Y4C接入上文的锁存器，根据锁存器的属性，实现led灯的控制。

### 软件电路

####  写灯的数据到 P0

低电平 = LED 亮

```c
P0 = 0x00;   // 全亮
```

#### 通过 138 选择锁存器

（例如选择 4 号锁存器）

```c
P2 = (P2 & 0x1F) | 0x80;
```

####  切换 LE，锁存数据

```c
P2 &= 0x1F;   // LE 由高到低，锁存
```

---

## 完整示例代码

```c
#include "stc15f2k60s2.h"

void Delay500ms(void)	//@12.000MHz
{
	unsigned char i, j, k;
	_nop_(); _nop_();
	i = 23; j = 205; k = 120;
	do { do { while (--k); } while (--j); } while (--i);
}

int main()
{
    while(1) 
    {
        P0 = 0xFF;                       // 熄灭LED
        P2 = (P2 & 0x1F) | 0x80;          // LE=1（透明）
        P2 = P2 & 0x1F;                   // LE=0（锁存）
        Delay500ms();					

        P0 = 0x00;                       // 点亮LED
        P2 = (P2 & 0x1F) | 0x80;          
        P2 = P2 & 0x1F;                   
        Delay500ms();					
    }
    
    return 0;
}
```

---

## 封装锁存器函数（可复用）

```c
int latch(uint8_t i)
{
    switch (i) {
        case 4: {P2 = (P2 & 0x1F) | 0x80; break;}
        case 5: {P2 = (P2 & 0x1F) | 0xA0; break;}
        case 6: {P2 = (P2 & 0x1F) | 0xC0; break;}
        case 7: {P2 = (P2 & 0x1F) | 0xE0; break;}
    }
    P2 &= 0x1F;       // 锁存
    return 0;
}
```

使用方法：

```c
P0 = ~0x01;
latch(4);   // 选择第4个锁存器
```

---

## 总结（最重要的记住这些）

| 芯片          | 作用                |
| ----------- | ----------------- |
| **74HC573** | 保存 LED 电平、控制灯     |
| **74HC138** | 选择哪个锁存器工作         |
| **74HC02**  | 信号反相              |
| **P0**      | LED 数据            |
| **P2**      | 控制 138 和 573 的 LE |

✅ **点灯核心逻辑：**

```
P0 写灯的数据
↓
P2 选择 74HC573
↓
LE 锁存
↓
LED 亮
```

