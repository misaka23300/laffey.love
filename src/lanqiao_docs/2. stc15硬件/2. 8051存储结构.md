# IAP15F2K60S2存储结构

我们使用的芯片是`IAP15F2K60S2`,这是宏晶半导体公司的51单片机。

内部集成的总SRAM大小为：2K 

- 256 idata 

- 1792 xdata

内部扩展RAM空间大小：1792Byte

可以拓展64K的外部数据存储器。

## 内部RAM

内部RAM共有256个字节，分为3个部分：

- 低128字节RAM(data)
- 高128字节RAM(idata)
- 特殊功能寄存器区

![image-20250926163851722](./8051%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.assets/image-20250926163851722.png)

> 低128字节的数据存储器既可直接寻址也可间接寻址。高128字节RAM与特殊功能寄存器区貌似共用相同的地址范围，都使用80H~FFH,地址空间虽然貌似重叠，但物理上是独立的，使用时通过不同的寻址方式加以区分。高128字节RAM只能间接寻址，特殊功能寄存器区只可直接寻址。

## 扩展RAM

64k的大小，xdata

一、STC15 的整体存储结构（总览）

STC15 属于 **增强型 8051（1T）**，但**存储体系仍然是 8051 的“四空间”模型**：

```
                 ┌──────────────┐
                 │  程序存储器  │  CODE
                 │ (Flash/ROM)  │
                 └──────────────┘
                         ▲
                         │
 ┌──────────┐    ┌──────────────┐
 │ SFR 区   │    │  内部 RAM    │  DATA / IDATA
 │ 0x80~FF  │    │  低 256B     │
 └──────────┘    └──────────────┘
                         ▲
                         │
                 ┌──────────────┐
                 │  XRAM        │  XDATA
                 │ (片内+片外)  │
                 └──────────────┘
```

------

# 二、各存储区 **详细拆解**

## 1️⃣ 程序存储器（CODE 区）

### 📌 本质

- 片内 **Flash**
- 存放：
  - 程序代码
  - `const` 常量
  - 查表数据

### 地址空间

- 最大 **64KB**
- STC15 常见型号：
  **16K / 32K / 64K Flash**

### 访问方式

- **PC 指针**
- `MOVC A, @A+DPTR`

### C 语言使用

```c
const unsigned char table[] = {1,2,3,4};
```

📌 默认放在 **CODE 区**

⚠️ 不能运行时修改！

------

## 2️⃣ 内部 RAM（DATA / IDATA）

### 📌 总大小

- **256 字节**
- 地址：`0x00 ~ 0xFF`

------

### 2.1 DATA 区（0x00 ~ 0x7F）

| 地址      | 用途                     |
| --------- | ------------------------ |
| 0x00~0x1F | 工作寄存器 R0~R7（4 组） |
| 0x20~0x2F | 位寻址区（128 bit）      |
| 0x30~0x7F | 普通 RAM                 |

#### 特点

- 访问最快
- 指令最少
- **强烈推荐放关键变量**

#### C 使用方式

```c
unsigned char a;          // 默认 DATA
bit flag;                 // 位寻址区
```

------

### 2.2 IDATA 区（0x80 ~ 0xFF）

- 实际也是内部 RAM
- 只能用 **间接寻址**
- 速度略慢

```c
idata unsigned char buf[100];
```

📌 Keil 会在 DATA 不够时自动用 IDATA

------

## 3️⃣ SFR 区（特殊功能寄存器）

### 地址范围

```
0x80 ~ 0xFF（与 IDATA 地址重叠，但硬件区分）
```

### 特点

- 控制外设、IO、定时器
- 部分可位寻址

### 常见 SFR

| 名称 | 地址 |
| ---- | ---- |
| P0   | 0x80 |
| SP   | 0x81 |
| DPL  | 0x82 |
| DPH  | 0x83 |
| PSW  | 0xD0 |
| ACC  | 0xE0 |
| B    | 0xF0 |

```c
P1 = 0xFF;
TR0 = 1;
```

------

## 4️⃣ XDATA（外部数据存储器）

### 📌 STC15 的“重点优势”

- **片内集成 XRAM**
- 常见：**1K / 4K / 8K**

### 特点

- 地址空间最大 64KB
- 访问慢于 DATA
- 但容量大

### C 使用

```c
xdata unsigned char rx_buf[512];
```

📌 非常适合：

- 通信缓冲
- 数组
- 日志数据

------

# 三、STC15 的变量初始化机制（重点）

## 1️⃣ 启动流程（复位后）

```
复位 →
  清零部分 RAM →
  初始化全局变量 →
  main()
```

------

## 2️⃣ 哪些变量会被“自动初始化”？

### ✅ 会初始化的

| 类型     | 位置                 | 行为     |
| -------- | -------------------- | -------- |
| 全局变量 | DATA / IDATA / XDATA | 自动清零 |
| 静态变量 | 同上                 | 自动清零 |
| const    | CODE                 | 固化     |

```c
int a;          // = 0
static int b;   // = 0
```

------

### ❌ 不会初始化的

| 类型                   | 说明 |
| ---------------------- | ---- |
| 局部自动变量           | 栈上 |
| 未显式初始化的局部数组 | 栈   |

```c
void foo(void)
{
    int x;      // 未定义
}
```

------

## 3️⃣ 不同存储区初始化细节

### DATA / IDATA

- **直接清零**
- 速度最快

------

### XDATA（非常关键）

⚠️ **不是全部 XDATA 都清零**

STC15 的启动代码通常：

- **只初始化被使用的 XDATA 段**
- 大数组可能不自动清零（看编译器）

👉 **工程建议：大 XDATA 手动初始化**

```c
memset(rx_buf, 0, sizeof(rx_buf));
```

------

## 4️⃣ const + xdata 的坑（非常容易踩）

```c
const xdata unsigned char table[] = {1,2,3};
```

⚠️ 实际含义是：

> “XDATA 中的常量” → **要拷贝到 RAM**

👉 会浪费 RAM！

### 正确方式

```c
const unsigned char table[] = {1,2,3};   // CODE
```

------

# 四、常见变量声明方式对照表（实战）

| 写法                   | 存储区 | 建议用途 |
| ---------------------- | ------ | -------- |
| `unsigned char a;`     | DATA   | 高频变量 |
| `bit flag;`            | 位区   | 状态标志 |
| `idata char buf[20];`  | IDATA  | 中小数组 |
| `xdata char buf[512];` | XDATA  | 通信缓冲 |
| `const char tab[];`    | CODE   | 查表     |

------

# 五、栈（Stack）在 STC15 中的位置

- 默认在 **DATA 区**
- 由 `SP` 指针管理
- 函数嵌套深 → 栈容易溢出

```c
SP = 0x30;   // 手动设置栈起始
```

📌 工程必做！

------

# 六、工程级总结（记这 6 条）

1. **DATA 最快，最宝贵**
2. **XDATA 容量大，但慢**
3. **const 一定放 CODE**
4. **大数组不要放 DATA**
5. **局部变量不自动清零**
6. **一定要规划栈位置**
